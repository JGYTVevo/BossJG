<?php


namespace Boss\entity;

use Boss\Loader;
use Boss\task\ZeusDeployTask;
use pocketmine\block\Block;
use pocketmine\block\Ladder;
use pocketmine\block\Vine;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\StringTag;
use pocketmine\nbt\tag\IntTag;
use pocketmine\nbt\tag\FloatTag;
use pocketmine\math\Vector3;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;
use pocketmine\timings\Timings;

class ZeusBoss extends HumanBoss
{

    /** @var float $gravity */
    protected $gravity = 0.08;

    /** @var float $drag */
    protected $drag = 0.02;

    /** @var float $jumpVelocity */
    protected $jumpVelocity = 0.42;

    /** @var int $attackDelay */
    private $attackDelay;

    /** @var bool $isBaby */
    public $isBaby = false;

    /** @var bool $locked */
    private $locked = false;

    /** @var int $lockTicker */
    private $lockTicker = 0;

    /** @var Vector3 $moveDirection */
    private $moveDirection;

    protected $stepHeight = 0;

    /**
     * ZeusBoss constructor.
     * @param Level $level
     * @param CompoundTag $nbt
     */
    public function __construct(Level $level, CompoundTag $nbt){

        //give zeus the skin
        $skin = Loader::$ins->getSkin('zeus');
        $nbt->setTag(new CompoundTag('Skin', [
            new StringTag('Data', $skin->getSkinData()),
            new StringTag('Name', 'Standard_CustomSlim')]));

        $this->skin = $skin;

        parent::__construct($level, $nbt);

        if (!$this->namedtag->hasTag("Scale", FloatTag::class)) {
            $this->namedtag->setFloat("Scale", 1.0, true);
        }

        $this->getDataPropertyManager()->setFloat(Entity::DATA_SCALE, $this->namedtag->getFloat("Scale"));

    }

    public function initEntity(): void{
        parent::initEntity();
        if($this->namedtag->hasTag('isBaby', IntTag::class)) {
            if ($this->namedtag->getInt('isBaby') == 1) {
                $this->setAsBaby(true);
            }
        }
    }

    public function saveNBT(): void
    {
        $this->namedtag->setFloat("Scale", $this->getScale(), true);
        $this->namedtag->setInt('isBaby', $this->isBaby ? 1 : 0);
        parent::saveNBT(); // TODO: Change the autogenerated stub
    }

    public function getName(): string
    {
        return 'Zeus';
    }


    /**
     * @param Entity $player
     */
    public function attackEntity(Entity $player){
        if($this->attackDelay > 10 && $this->distanceSquared($player) < 2){
            $this->attackDelay = 0;

            $damage = 14;

            $ev = new EntityDamageByEntityEvent($this, $player, EntityDamageEvent::CAUSE_ENTITY_ATTACK,
                $damage);
            $player->attack($ev);
        }
    }

    /**
     * @param EntityDamageEvent $source
     */
    public function attack(EntityDamageEvent $source): void
    {
        parent::attack($source);
        if(!$source->isCancelled()){

            $suffix = $this->isBaby ? 'baby' : 'adult';

            if(!Loader::$ins->getProperty('zeus', 'useBar_' . $suffix, 'health')){
                return;
            }

            $intoLines = Loader::$ins->getProperty('zeus', 'healthBarLines_' . $suffix, 'health');

            $nametag = Loader::$ins->calculateNametag($this->getHealth(), $this->getMaxHealth(), $intoLines);
            $this->sendData($this->getViewers(), [self::DATA_NAMETAG => [self::DATA_TYPE_STRING, $nametag]]);
            $this->setNameTag($nametag);
        }
    }


    public function getDrops(): array
    {
        return Loader::$ins->getDrops('zeus', $this->isBaby);
    }

    /**
     * @param bool $reborn
     */
    public function setAsBaby(bool $reborn = false) : void{
        $this->setScale(0.5);
        $this->setSkin(Loader::$ins->getSkin('small_zeus'));

        $max = Loader::$ins->getProperty('zeus', 'maxHealth_baby', 'health');
        $intoLines = Loader::$ins->getProperty('zeus', 'healthBarLines_baby', 'health');

        $this->setMaxHealth($max);
        $this->setHealth($max);


        if(Loader::$ins->getProperty('zeus', 'useBar_baby', 'health')){
            $this->setNameTag(Loader::$ins->calculateNametag($max, $max, $intoLines));
        }

        if(!$reborn) {
            $this->setMaxHealth(Loader::$ins->getProperty('zeus', 'health', 'maxHealth_baby'));
            $this->setHealth(Loader::$ins->getProperty('zeus', 'health', 'maxHealth_baby'));
        }

        $this->isBaby = true;
    }

    public function setAnAdult() : void{
        $this->setScale(2);

        $max = Loader::$ins->getProperty('zeus', 'maxHealth_adult', 'health');
        $intoLines = Loader::$ins->getProperty('zeus', 'healthBarLines_adult', 'health');

        $this->setMaxHealth($max);
        $this->setHealth($max);

        if(Loader::$ins->getProperty('zeus', 'useBar_adult', 'health')) {
            $this->setNameTag(Loader::$ins->calculateNametag($max, $max, $intoLines));
        }

        $spawnBaby = boolval(Loader::$ins->getProperty('zeus', 'spawn', 'baby'));
        if($spawnBaby){
            Loader::$ins->getScheduler()->scheduleRepeatingTask($task = new ZeusDeployTask($this->getId()), 20 * 100);
        }
    }

    /**
     * @param Entity $e
     */
    public function revenge(Entity $e){
        $amount = intval(Loader::$ins->getProperty('zeus', 'amount', 'baby'));
        $radius = 3;

        $diff = intval(360 / $amount);
        for($theta = 0; $theta <= 360; $theta += $diff){
            $offsetX = $radius * sin($theta);
            $offsetZ = $radius * cos($theta);

            $nbt = Entity::createBaseNBT($e->getPosition()->add($offsetX, 1.5, $offsetZ));
            $bossEntity = Entity::createEntity('ZeusBoss', $this->level, $nbt);
            $bossEntity->setAsBaby();
            $bossEntity->spawnToAll();

        }
    }

    /**
     * @return bool|mixed|Player
     */
    private function getNearestPlayer() {
        $dis = PHP_INT_MAX;
        $player = false;
        foreach($this->getViewers() as $p){
            if($p->distance($this) < $dis){
                $dis = $p->distance($this);
                $player = $p;
            }
        }
        return (($dis <= 16) ? $player : false);
    }

    /**
     * @param $num
     * @return float
     */
    private function toFloat($num) : float{
        while(((abs($num) > 1) or (abs($num) < 0.1)) and (abs($num) > 0)) {
            if(abs($num) > 1) $num /= 10;
            if(abs($num) < 0.1) $num *= 10;
        }
        return $num;
    }

    /**
     * @param float $dx
     * @param float $dy
     * @param float $dz
     */
    public function move(float $dx, float $dy, float $dz) : void {
        $this->blocksAround = null;
        Timings::$entityMoveTimer->startTiming();
        $movX = $dx;
        $movY = $dy;
        $movZ = $dz;
        if($this->keepMovement) {
            $this->boundingBox->offset($dx, $dy, $dz);
        }else {
            $this->ySize *= 0.4;
            $axisalignedbb = clone $this->boundingBox;
            $list = $this->level->getCollisionCubes($this, $this->boundingBox->addCoord($dx, $dy, $dz), false);
            foreach($list as $bb) {
                $dy = $bb->calculateYOffset($this->boundingBox, $dy);
            }
            $this->boundingBox->offset(0, $dy, 0);
            $fallingFlag = ($this->onGround or ($dy != $movY and $movY < 0));
            foreach($list as $bb) {
                $dx = $bb->calculateXOffset($this->boundingBox, $dx);
            }
            $this->boundingBox->offset($dx, 0, 0);
            foreach($list as $bb) {
                $dz = $bb->calculateZOffset($this->boundingBox, $dz);
            }
            $this->boundingBox->offset(0, 0, $dz);
            if($this->stepHeight > 0 and $fallingFlag and $this->ySize < 0.05 and ($movX != $dx or $movZ != $dz)) {
                $cx = $dx;
                $cy = $dy;
                $cz = $dz;
                $dx = $movX;
                $dy = $this->stepHeight;
                $dz = $movZ;
                $axisalignedbb1 = clone $this->boundingBox;
                $this->boundingBox->setBB($axisalignedbb);
                $list = $this->level->getCollisionCubes($this, $this->boundingBox->addCoord($dx, $dy, $dz), false);
                foreach($list as $bb) {
                    $dy = $bb->calculateYOffset($this->boundingBox, $dy);
                }
                $this->boundingBox->offset(0, $dy, 0);
                foreach($list as $bb) {
                    $dx = $bb->calculateXOffset($this->boundingBox, $dx);
                }
                $this->boundingBox->offset($dx, 0, 0);
                foreach($list as $bb) {
                    $dz = $bb->calculateZOffset($this->boundingBox, $dz);
                }
                $this->boundingBox->offset(0, 0, $dz);
                if(($cx ** 2 + $cz ** 2) >= ($dx ** 2 + $dz ** 2)) {
                    $dx = $cx;
                    $dy = $cy;
                    $dz = $cz;
                    $this->boundingBox->setBB($axisalignedbb1);
                }else {
                    $block = $this->level->getBlock($this->getSide(Vector3::SIDE_DOWN));
                    $blockBB = $block->getBoundingBox() ?? new AxisAlignedBB($block->x, $block->y, $block->z, $block->x + 1, $block->y + 1, $block->z + 1);
                    $this->ySize += $blockBB->maxY - $blockBB->minY;
                }
            }
        }
        $this->x = ($this->boundingBox->minX + $this->boundingBox->maxX) / 2;
        $this->y = $this->boundingBox->minY - $this->ySize;
        $this->z = ($this->boundingBox->minZ + $this->boundingBox->maxZ) / 2;
        $this->checkChunks();
//        $this->checkBlockCollision();
        $this->checkGroundState($movX, $movY, $movZ, $dx, $dy, $dz);
        $this->updateFallState($dy, $this->onGround);
        if($movX != $dx) {
            $this->motion->x = 0;
        }
        if($movY != $dy) {
            $this->motion->y = 0;
        }
        if($movZ != $dz) {
            $this->motion->z = 0;
        }
        //TODO: vehicle collision events (first we need to spawn them!)
        Timings::$entityMoveTimer->stopTiming();
    }

    /**
     * @param int $currentTick
     * @return bool
     */
    public function onUpdate(int $currentTick) : bool
    {
        if ($this->closed) {
            return false;
        }

        $tickDiff = $currentTick - $this->lastUpdate;
        $this->lastUpdate = $tickDiff;

        $this->entityBaseTick($tickDiff);

        if($this->isAlive()){
            $locked = $this->getNearestPlayer();
            if(!$locked){
                $this->locked = false;
                $this->motion->x = 0;
                $this->motion->z = 0;

            }else{
                $this->locked = $locked;

                if(++$this->lockTicker >= 10){
                    $targetDirection = new Vector3($this->toFloat($locked->x - $this->x), 0, $this->toFloat($locked->z - $this->z));

                    if($this->distance($this->locked) <= 8){

                        $this->motion->x = $targetDirection->x * 0.3;
                        $this->motion->z = $targetDirection->z * 0.3;

                        $hitDistance = $this->isBaby ? 1.5 : 2.5;
                        $hitDamage = $this->isBaby ? 5 : 14;

                        if($this->distance($this->locked) <= $hitDistance){
                            $source = new EntityDamageByEntityEvent($this, $locked, EntityDamageEvent::CAUSE_ENTITY_ATTACK, $hitDamage);
                            $locked->attack($source);
                        }
                    }else{
                        $this->motion->x = 0;
                        $this->motion->z = 0;

                        $this->lockTicker = 0;
                    }
                }
            }

            $friction = 1 - $this->drag;
            $this->motion->y -= $this->gravity;
            $this->motion->y *= $friction;


            $this->move($this->motion->x,$this->motion->y, $this->motion->z);
            $this->updateMovement();
        }
        return true;
    }

}